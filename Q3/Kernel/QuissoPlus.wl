(* -*- mode:math -*- *)

(* A special package to help study the local unitary equivalence between
   quantum states. *)

Needs["Q3`"]

BeginPackage["Q3`"]

`QuissoPlus`$Version = StringJoin[
  $Input, " v",
  StringSplit["$Revision: 1.4 $"][[2]], " (",
  StringSplit["$Date: 2021-07-21 15:16:26+09 $"][[2]], ") ",
  "Mahn-Soo Choi"
 ];

ClearAll @@ Evaluate @ Unprotect[
  QuissoCorrelationTensor, QuissoCorrelationMatrix,
  QuissoNormalState
 ];


Begin["`Private`"]

(* QuissoNormalState *)

QuissoNormalState::usage = "QuissoNormalState[expr] or QuissoNormalState[expr, {S1, S2, ...}] gives the normal form (also known as standard form) of the given state specified by expr. See, e.g., Kraus (PRL, 2010; PRA, 2010). In Martins (PRA, 2015), it is called a reference form."

QuissoNormalState[ expr_ ] := Module[
  (* expr: Ket[] expression *)
  { ss = Qubits @ expr },
  Fold[ QuissoNormalState, expr, ss ]
 ]

QuissoNormalState[v_, S_?QubitQ] := Module[
  { p, u, m, op },
  m = Matrix @ QuissoReduced[v, {S}];
  {p, u} = Eigensystem[m];
  u = Transpose[ Normalize /@ u ];
  op = ExpressionFor[ u, {S} ];
  Simplify[ Dagger[op] ** v ]
 ]

(* QuissoCorrelationTensor *)

QuissoCorrelationTensor::usage = "QuissoCorrelationTensor[v] gives the Association of the Pauli decomposition coefficients for the density matrix corresponding to the pure state a. The pure state vector should be given in a Ket expression."

(* Method 1: This is fast, but results in "Recursion depth of 1024 exceeded
   during evaluation of ..." error when the state vector includes many terms
   for a large number of qubits. *)

(*
QuissoCorrelationTensor[v_] :=
  QuissoCoefficientTensor[ ExpressionFor @ Dirac[v, Dagger[v]] ]

QuissoCorrelationTensor[v_, n_Integer] :=
  QuissoCoefficientTensor[ ExpressionFor @ Dirac[v, Dagger[v]], n ]

QuissoCorrelationTensor[v_, {n_Integer}] :=
  QuissoCoefficientTensor[ ExpressionFor @ Dirac[v, Dagger[v]], {n} ]
 *)

(* Method 2: This is slower than Method 1 above, but does not suffer from the
   recursion limit error. *)

QuissoCorrelationTensor[v_] :=  With[
  { qq = Qubits @ v },
  QuissoCorrelationTensor[v, Length[qq]]
 ]

QuissoCorrelationTensor[v_, n_Integer] := 
 Join @@ Table[ QuissoCorrelationTensor[v, {k}], {k, 0, n} ]

QuissoCorrelationTensor[v_, {0}] := With[
  { qq = Qubits @ v },
  Association[{1} -> Multiply[Dagger[v], v] Power[2, -Length[qq]]]
 ]

QuissoCorrelationTensor[v_, {n_Integer}] := Module[
  { qq = Qubits @ v,
    nn, op, jj, cc },
  nn = Length @ qq;
  qq = FlavorNone @ Subsets[qq, {n}];
  jj = Map[(#[All]) &, qq, {2}];
  op = Map[Outer[Multiply, Sequence @@ #, 1] &, jj];
  cc = Dagger[v] ** op ** v;
  Association[Thread[qq -> cc]] Power[2, -nn]
 ]


(* QuissoCorrelationMatrix *)

QuissoCorrelationMatrix::usage = "QuissoCorrelationMatrix[a] analyses the correlation tesnor in the Association a; it takes the product of each tensor with itself and contract over the indices but two belonging to the same quibt. The result is an Association of 3x3 matrices describing the transformation of the state vector (associated with the Association a) under local unitary (LU) transformations. The association a is usually generated by QuissoCoefficientTensor[] or QuissoCorrelationTensor[]."

QuissoCorrelationMatrix[a_Association] := Module[
  { aa },
  aa = DeleteCases[ QuissoCorrelationMatrix /@ a, Nothing ];
  aa = Merge[ KeyValueMap[Thread[#1 -> #2]&, aa], Join ];
  (* DeleteCases[ aa, (ZeroMatrix[3] | IdentityMatrix[3]), 2 ] *)
  Return[aa];
 ]

QuissoCorrelationMatrix[T_] := Nothing /; TensorRank[T] < 2 

QuissoCorrelationMatrix[T_] := Module[
  { n = TensorRank[T],
    TT = TensorProduct[T, T],
    kk, CC },
  kk = Reverse @ Subsets[Range[n], {n - 1}];
  kk = Map[Transpose[{#, # + n}] &, kk];
  CC = TensorContract[TT, #] & /@ kk;
  Power[2,2n] CC (* make elements order of unity *)
 ]


End[]

Q3Protect[];

EndPackage[]
